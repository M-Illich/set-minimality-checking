package com.autoreason.setmincheck.setobjects;

import java.util.Set;

/**
 * A {@link SetConverter} implementation for {@link BoolVectorSet}
 *
 */
public class BoolVectorSetConverter extends AbstractSetConverter<boolean[], Integer> {

	/**
	 * Create a {@code BoolVectorSetConverter} instance where the length for the
	 * {@code boolean[]} set representation generated by {@link #convertSet(Set)} is
	 * determined by the converted set's size
	 * 
	 * @param len An {@code int} greater than 1
	 */
	BoolVectorSetConverter() {
		// length of set representation is determined by set size
		this.convertAttribute = -1;
	}

	/**
	 * Create a {@code BoolVectorSetConverter} instance with predefined length for
	 * the {@code boolean[]} set representation generated by
	 * {@link #convertSet(Set)}
	 * 
	 * @param len An {@code int} greater than 1
	 */
	BoolVectorSetConverter(int len) {
		this.convertAttribute = len;
	}

	/**
	 * Note: The length of the resulting {@code boolean[]} is the smallest multiple
	 * of 64 that holds the size of the set
	 */
	@Override
	public boolean[] convertSet(Set<?> set) {
		int len = convertAttribute;
		if (len < 1) {
			// determine length of array as multiple of 64 based on set size
			len = defineLength(set.size());
		}
		boolean[] convertedSet = new boolean[len];

		// use elements of set to define position of true values
		for (Object e : set) {
			int hashcode = e.hashCode();
			// only allow positive values
			if (hashcode < 0) {
				hashcode *= -1;
			}
			// set true value in appropriate position
			convertedSet[hashcode % len] = true;
		}

		return convertedSet;
	}

	/**
	 * Define length for an array as the smallest multiple of the static value
	 * {@link #DIVISOR} that comprises the given {@code size} value
	 * 
	 * @param size A positive {@code int} value related to the size of some set
	 * @return An {@code int} for the smallest multiple of the static value
	 *         {@link #DIVISOR} that comprises the given {@code size} value
	 */
	public static int defineLength(int size) {
		return (size / DIVISOR + ((size % DIVISOR == 0) ? 0 : 1)) * 64;	// TODO ?
	}

}
