package com.autoreason.setmincheck.setobjects;

import java.util.Arrays;
import java.util.Set;

import com.autoreason.setmincheck.AbstractSetRepMatchProvider;

/**
 * An implementation of {@link AbstractSetRepMatchProvider} for
 * {@link BitVectorSet}
 *
 */
public class BitVecSetMatchProvider extends AbstractSetRepMatchProvider<BitVectorSet, long[]> {

	@Override
	public BitVectorSet getSmallestMatchGreaterOrEqual(BitVectorSet current, Set<?> test) {
		// return null if no match can be found
		if (current == null) {
			return null;
		}

		// bit vector representation of candidate
		long[] candArray = current.setRepresentation.clone();
		int candLength = candArray.length;
		// bit vector representation of test
		long[] testArray;
		// bit vector for next match
		long[] next;
		// upper limit of possible array length for test set
		int maxLenTest = test.size() / 64 + 1;

		// look for match
		if (candLength <= maxLenTest) {
			// convert test to appropriate bit vector representation
			testArray = getRepresentation(test, candLength);

			// compare vectors
			int compareValue = 0;
			for (int i = candArray.length - 1; i >= 0; i--) {
				// subset can only have 1-bits at same positions as the superset bit vector
				if ((testArray[i] | candArray[i]) != testArray[i]) {
					// no subset candidate -> check if smaller or greater
					compareValue = Long.compare(candArray[i], testArray[i]);
					break;
				}
			}

			// check if current is already a match
			if (compareValue == 0) {
				next = candArray;
			} else {
				// check if next match can be found
				if (compareValue == 1) {
					// previous is not smaller than test -> no next match possible
					// try next length for representation
					if (candLength < maxLenTest) {
						candLength++;
						// start with empty candidate of increased size
						candArray = new long[candLength];
						// convert test to new bit vector representation
						testArray = getRepresentation(test, candLength);
						// define bit vector of next match by adding new lowest bit taken from test
						next = add(candArray, getLowestBit(testArray));
					} else {
						return null;
					}

				}
				// current candidate is smaller than test -> compute next match
				else {
					// keep all different bits
					long[] xorArray = xor(testArray, candArray);
					// get bits that only occur in candidate array
					long[] onlyCand = and(xorArray, candArray);
					// initialize array for remaining test bits
					long[] remainTest;

					// check if candidate only contains bits from test, i.e., onlyCand is zero
					if (Arrays.equals(onlyCand, new long[onlyCand.length])) {
						// remaining test bits correlate to XOR result
						remainTest = xorArray;
					} else {
						// get highest bit from all bits that only occur in candidate
						long[] high = getHighestBit(onlyCand);
						// get all bits that only appear in test and are higher than high
						remainTest = removeLowBits(and(testArray, xorArray), high);
					}

					// get the lowest bit from the remaining test bits
					long[] low = getLowestBit(remainTest);
					// define bit vector of next match by adding the low bit and removing all
					// foregoing bits
					next = removeLowBits(add(candArray, low), low);

				}
			}

			// return BitVectorSet representation of next match
			return new BitVectorSet(next);
		}
		// if candidate is already larger than the set it cannot be a match
		else {
			return null;
		}

	}

	/**
	 * Remove all bits from {@code array} that are lower than the one bit given by
	 * {@code low}
	 * 
	 * @param array A {@code long[]}
	 * @param low   A {@code long[]} generated by {@link #getLowestBit(long[])}
	 * @return A {@code long[]} containing all the bits from {@code array} except
	 *         the ones that appear at lower positions than the bit given by
	 *         {@code low}
	 */
	static long[] removeLowBits(long[] array, long[] low) {
		int lowLen = low.length;
		// remover contains initially only zero
		long[] remover = new long[lowLen];
		// set all bits up to the only bit of low to 0 and the remaining ones to 1
		remover[lowLen - 1] = ~(low[lowLen - 1] - 1);

		return and(array, remover);
	}

	/**
	 * Get a {@code long} array which contains the lowest 1-bit of {@code bitVector}
	 * as rightmost 1-bit entry
	 * 
	 * @param bitVector A {@code long[]}
	 * @return A {@code long[]} which contains the lowest 1-bit of {@code bitVector}
	 *         as only 1-bit entry, or {@code long} entries with value zero if no
	 *         bit could be found
	 */
	static long[] getLowestBit(long[] bitVector) {

		int len = bitVector.length;
		long lowBit = 0;
		int i = 0;
		// go through long values of array until lowest 1-bit found
		do {
			lowBit = Long.lowestOneBit(bitVector[i]);
			i++;
		} while (lowBit == 0 && i < len);

		// transfer lowBit to long array
		long[] lowArray = new long[i];
		lowArray[i - 1] = lowBit;
		return lowArray;
	}

	/**
	 * Get a {@code long} array which contains the highest 1-bit of
	 * {@code bitVector} as only 1-bit entry
	 * 
	 * @param bitVector A {@code long[]}
	 * @return A {@code long[]} which contains the highest 1-bit of
	 *         {@code bitVector} as only 1-bit entry, or {@code long} entries with
	 *         value zero if no bit could be found
	 */
	static long[] getHighestBit(long[] bitVector) {

		long highBit = 0;
		int i = bitVector.length - 1;
		// go through long values of array until highest 1-bit found
		while (highBit == 0 && i >= 0) {
			highBit = Long.highestOneBit(bitVector[i]);
			i--;
		}

		// transfer highBit to long array
		long[] highArray = new long[i + 2];
		highArray[i + 1] = highBit;
		return highArray;
	}

	/**
	 * Compute the sum of the values of each position of two provided {@code long[]}
	 * objects
	 * 
	 * @param a A {@code long[]}
	 * @param b A {@code long[]}
	 * @return A {@code long[]} that contains the sum of the values for each
	 *         position of {@code a} and {@code b}
	 */
	static long[] add(long[] a, long[] b) {

		int len = a.length;
		int lenB = b.length;

		// create new array containing the long values as sum
		long[] ab;
		if (len > lenB) {
			len = lenB;
			ab = a.clone();
			// smaller one is added to bigger array (see below)
			a = b.clone();
		} else {
			ab = b.clone();
		}

		// create sum for each array position
		for (int i = 0; i < len; i++) {
			ab[i] += a[i];
		}
		return ab;
	}

	/**
	 * Subtract 1 from the value defined by the bit vector that results from the
	 * appending of the {@code long} values of the given array
	 * 
	 * @param arr A {@code long[]}
	 * @return A {@code long[]} whose elements define a value being 1 smaller than
	 *         the value given by the {@code long} values of {@code arr}
	 */
	static long[] subtractOne(long[] arr) {
		// define new array
		long[] sub = arr.clone();
		int i = 0;
		long val = 0;
		// subtract 1 from values starting at first array entry until one != 0 is found
		do {
			val = sub[i];
			sub[i] = val - 1;
			i++;
		} while (val == 0 && i < sub.length);

		return sub;
	}

	/**
	 * Compute complement of {@code long} values given in an array
	 * 
	 * @param arr A {@code long[]}
	 * @return A {@code long[]} containing the complement values of the given array
	 *         {@code a}
	 */
	static long[] complementOf(long[] arr) {
		int len = arr.length;
		// create new array containing the complement long values
		long[] ac = new long[len];
		for (int i = 0; i < len; i++) {
			ac[i] = ~arr[i];
		}
		return ac;
	}

	/**
	 * Perform bitwise AND operation on the values of each position of the provided
	 * long arrays
	 * 
	 * @param a A {@code long[]}
	 * @param b A {@code long[]}
	 * @return A {@code long[]} with values computed by bitwise AND operations of
	 *         the arrays' {@code long} values
	 */
	static long[] and(long[] a, long[] b) {

		int len = a.length;
		int lenB = b.length;

		// create new array containing the bitwise AND operation of the long
		long[] ab;
		if (len > lenB) {
			len = lenB;
			// initialize with bigger array
			ab = a.clone();
			a = b.clone();
		} else {
			ab = b.clone();
		}

		// compute bitwise AND for each array position
		for (int i = 0; i < len; i++) {
			ab[i] &= a[i];
		}
		return ab;
	}

	/**
	 * Perform bitwise XOR operation on the values of each position of the provided
	 * long arrays
	 * 
	 * @param a A {@code long[]}
	 * @param b A {@code long[]}
	 * @return A {@code long[]} with values computed by bitwise XOR operations of
	 *         the arrays' {@code long} values
	 */
	static long[] xor(long[] a, long[] b) {

		int len = a.length;
		int lenB = b.length;

		// create new array containing the long values as sum
		long[] ab;
		if (len > lenB) {
			len = lenB;
			ab = a.clone();
			// smaller one is added to bigger array (see below)
			a = b.clone();
		} else {
			ab = b.clone();
		}

		// compute bitwise XOR for each array position
		for (int i = 0; i < len; i++) {
			ab[i] ^= a[i];
		}
		return ab;
	}

	@Override
	protected long[] convertSet(Set<?> set, Object attr) {
		return new BitVectorSet(new long[1]).convertSet(set, attr);
	}

}
