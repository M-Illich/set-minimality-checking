package com.autoreason.setmincheck.setobjects;

import java.util.Arrays;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Set;

import com.autoreason.setmincheck.MinimalityChecker;

/**
 * Use the {@link BitVectorSet} representation for {@link Set} objects to check
 * set minimality
 * 
 */
public class BitVectorSetChecker extends MinimalityChecker<BitVectorSet> {

	// hash table to store different BitVectorSet representations, i.e. long[] of
	// different lengths, of tested sets
	HashMap<String, long[]> hashtable = new HashMap<String, long[]>();

	@Override
	protected boolean subsetOf(BitVectorSet cand, Set<?> test) {
		// all elements of candidate's original set have to occur in test set
		return test.containsAll(cand.set);
	}

	@Override
	public BitVectorSet getNextMatch(BitVectorSet previous, Set<?> test) {
		// bit vector representation of candidate
		long[] candArray = previous.setRepresentation.clone();
		int candLength = candArray.length;
		// bit vector representation of test
		long[] testArray;
		// bit vector for next match
		long[] next;

		// look for next match
		if (candLength <= test.size()) {
			// convert test to appropriate bit vector representation
			testArray = transform(test, candLength);

			// check if next match can be found
			if ((previous.compareTo(new BitVectorSet(testArray)) > -1)) {
				// previous is not smaller than test -> no next match possible
				// try next length for representation
				if (candLength < test.size()) {
					candLength++;
					// start with empty candidate of increased size
					candArray = new long[candLength];
					// convert test to new bit vector representation
					testArray = transform(test, candLength);
					// define bit vector of next match by adding new lowest bit taken from test
					next = add(candArray, getLowestBit(testArray));
				} else {
					return null;
				}

			} else {

				// keep all different bits
				long[] xorArray = xor(testArray, candArray);
				// get bits that only occur in candidate array
				long[] onlyCand = and(xorArray, candArray);
				// initialize array for remaining test bits
				long[] remainTest;
				// check if candidate only contains bits from test, i.e., onlyCand is zero
				if (Arrays.equals(onlyCand, new long[onlyCand.length])) {
					// remaining test bits correlate to XOR result
					remainTest = xorArray;
				} else {
					// get highest bit from all bits that only occur in candidate
					long[] high = getHighestBit(onlyCand);
//		TODO			// define vector where every position after highest bit is zero
//					long[] lowRemover = complementOf(subtractOne(high));
//					// remove bits from the vector that only contains bits from test
//					remainTest = and(lowRemover, and(testArray, xorArray));

					// get all bits that only appear in test and are higher than high
					remainTest = removeLowBits(and(testArray, xorArray), high);

				}

				// get the lowest bit from the remaining test bits
				long[] low = getLowestBit(remainTest);
//		TODO		// define vector where every position after lowest bit is zero
//				long[] lowRemover = complementOf(subtractOne(low));
//				// define bit vector of next match by adding new lowest bit
//				next = and(add(candArray, low), lowRemover);	

				// define bit vector of next match by adding the low bit and removing all
				// foregoing bits
				next = removeLowBits(add(candArray, low), low);

			}
			// return BitVectorSet representation of next match
			return new BitVectorSet(next);
		}
		// if candidate is already larger than the set it cannot be a match
		else {
			return null;
		}

	}

	/**
	 * Remove all bits from {@code array} that are lower than the one bit given by
	 * {@code low}
	 * 
	 * @param array A {@code long[]}
	 * @param low   A {@code long[]} generated by {@link #getLowestBit(long[])}
	 * @return A {@code long[]} containing all the bits from {@code array} except
	 *         the ones that appear at lower positions than the bit given by
	 *         {@code low}
	 */
	long[] removeLowBits(long[] array, long[] low) {
		int lowLen = low.length;
		// remover contains initially only zero
		long[] remover = new long[lowLen];
		// set all bits up to the only bit of low to 0 and the remaining ones to 1
		remover[lowLen - 1] = ~(low[lowLen - 1] - 1);

		return and(array, remover);
	}

	/**
	 * Get a {@code long} array which contains the lowest 1-bit of {@code bitVector}
	 * as rightmost 1-bit entry
	 * 
	 * @param bitVector A {@code long[]}
	 * @return A {@code long[]} which contains the lowest 1-bit of {@code bitVector}
	 *         as only 1-bit entry, or {@code long} entries with value zero if no
	 *         bit could be found
	 */
	long[] getLowestBit(long[] bitVector) {

		int len = bitVector.length;
		long lowBit = 0;
		int i = 0;
		// go through long values of array until lowest 1-bit found
		do {
			lowBit = Long.lowestOneBit(bitVector[i]);
			i++;
		} while (lowBit == 0 && i < len);

		// transfer lowBit to long array
		long[] lowArray = new long[i];
		lowArray[i - 1] = lowBit;
		return lowArray;
	}

	/**
	 * Get a {@code long} array which contains the highest 1-bit of
	 * {@code bitVector} as only 1-bit entry
	 * 
	 * @param bitVector A {@code long[]}
	 * @return A {@code long[]} which contains the highest 1-bit of
	 *         {@code bitVector} as only 1-bit entry, or {@code long} entries with
	 *         value zero if no bit could be found
	 */
	long[] getHighestBit(long[] bitVector) {

		long highBit = 0;
		int i = bitVector.length - 1;
		// go through long values of array until highest 1-bit found
		while (highBit == 0 && i >= 0) {
			highBit = Long.highestOneBit(bitVector[i]);
			i--;
		}

		// transfer highBit to long array
		long[] highArray = new long[i + 2];
		highArray[i + 1] = highBit;
		return highArray;
	}

	/**
	 * Compute the sum of the values of each position of two provided {@code long[]}
	 * objects
	 * 
	 * @param a A {@code long[]}
	 * @param b A {@code long[]}
	 * @return A {@code long[]} that contains the sum of the values for each
	 *         position of {@code a} and {@code b}
	 * 
	 */
	long[] add(long[] a, long[] b) {

		int len = a.length;
		int lenB = b.length;

		// create new array containing the long values as sum
		long[] ab;
		if (len > lenB) {
			len = lenB;
			ab = a.clone();
			// smaller one is added to bigger array (see below)
			a = b.clone();
		} else {
			ab = b.clone();
		}

		// create sum for each array position
		for (int i = 0; i < len; i++) {
			ab[i] += a[i];
		}
		return ab;
	}

	/**
	 * Subtract 1 from the value defined by the bit vector that results from the
	 * appending of the {@code long} values of the given array
	 * 
	 * @param arr A {@code long[]}
	 * @return A {@code long[]} whose elements define a value being 1 smaller than
	 *         the value given by the {@code long} values of {@code arr}
	 */
	long[] subtractOne(long[] arr) {
		// define new array
		long[] sub = arr.clone();
		int i = 0;
		long val = 0;
		// subtract 1 from values starting at first array entry until one != 0 is found
		do {
			val = sub[i];
			sub[i] = val - 1;
			i++;
		} while (val == 0 && i < sub.length);

		return sub;
	}

	/**
	 * Compute complement of {@code long} values given in an array
	 * 
	 * @param arr A {@code long[]}
	 * @return A {@code long[]} containing the complement values of the given array
	 *         {@code a}
	 */
	long[] complementOf(long[] arr) {
		int len = arr.length;
		// create new array containing the complement long values
		long[] ac = new long[len];
		for (int i = 0; i < len; i++) {
			ac[i] = ~arr[i];
		}
		return ac;
	}

	/**
	 * Perform bitwise AND operation on the values of each position of the provided
	 * long arrays
	 * 
	 * @param a A {@code long[]}
	 * @param b A {@code long[]}
	 * @return A {@code long[]} with values computed by bitwise AND operations of
	 *         the arrays' {@code long} values
	 */
	long[] and(long[] a, long[] b) {

		int len = a.length;
		int lenB = b.length;

		// create new array containing the bitwise AND operation of the long
		long[] ab;
		if (len > lenB) {
			len = lenB;
			// initialize with bigger array
			ab = a.clone();
			a = b.clone();
		} else {
			ab = b.clone();
		}

		// compute bitwise AND for each array position
		for (int i = 0; i < len; i++) {
			ab[i] &= a[i];
		}
		return ab;
	}

	/**
	 * Perform bitwise XOR operation on the values of each position of the provided
	 * long arrays
	 * 
	 * @param a A {@code long[]}
	 * @param b A {@code long[]}
	 * @return A {@code long[]} with values computed by bitwise XOR operations of
	 *         the arrays' {@code long} values
	 */
	long[] xor(long[] a, long[] b) {

		int len = a.length;
		int lenB = b.length;

		// create new array containing the long values as sum
		long[] ab;
		if (len > lenB) {
			len = lenB;
			ab = a.clone();
			// smaller one is added to bigger array (see below)
			a = b.clone();
		} else {
			ab = b.clone();
		}

		// compute bitwise XOR for each array position
		for (int i = 0; i < len; i++) {
			ab[i] ^= a[i];
		}
		return ab;
	}

	/**
	 * For set minimality checking, a match refers to a subset relation, which means
	 * that {@code candidate} must be a subset candidate of {@code test}
	 */
	@Override
	public boolean matches(BitVectorSet candidate, Set<?> test) {
		// handle null
		if (candidate == null || test == null) {
			return false;
		}
		// get long arrays
		long[] candArray = candidate.setRepresentation;
		// convert test to appropriate BitVectorSet representation
		long[] testArray = transform(test, candArray.length);

		// compare long values
		for (int i = 0; i < candArray.length; i++) {
			// subset can only have 1-bits at same positions as the superset bit vector
			if ((testArray[i] | candArray[i]) != testArray[i]) {
				// no subset candidate
				return false;
			}
		}
		// subset candidate confirmed
		return true;
	}

	/**
	 * Transform a {@link Set} element into a {@code long[]} of given length
	 * 
	 * @param set    A {@link Set}
	 * @param length An {@code int} that determines the length of the {@code long[]}
	 * @return A {@code long[]} that contains a bit vector representing the elements
	 *         of {@code set}
	 */
	public long[] transform(Set<?> set, int length) {

		// look for long array representation of given length in hash table
		String key = defineHashKey(set, length);
		long[] bv = hashtable.get(key);

		// no element found -> create new one
		if (bv == null) {
			// create bit vector of given length
			bv = new long[length];
			int bitNum = length * 64;
			/// use elements of set to define position of 1-bits
			for (Object e : set) {
				// determine position based on hash code
				int pos = e.hashCode() % bitNum;
				// only allow positive values
				if (pos < 0) {
					pos *= -1;
				}
				// set bit in appropriate long value
				bv[pos / 64] |= (long) 1 << pos;
			}
			// add representation to hash table
			hashtable.put(key, bv);
		}

		// return bit vector representing the set
		return bv;
	}

	/**
	 * Define a {@link String} that serves as key for a hash table
	 * 
	 * @param set A {@link Set}
	 * @param i   An {@link int} value
	 * @return A {@link String} based on the hashcode of {@code set} appended by the
	 *         space-separated value {@code i}
	 */
	private String defineHashKey(Set<?> set, int i) {
		// use hash code of set together with the given int value as key
		// TODO hashcode(); key not string better ?
		return set.size() + " " + i;
	}

}
